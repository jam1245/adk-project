"""
Artifact generation tools for the Program Execution Workbench.

These tools produce structured output documents (leadership briefs, CAM
narratives, risk register updates, action-item lists, 8D reports, and
contract change summaries) and persist them to the ``outputs/`` directory.

Each function:
- Has full type hints and a detailed docstring.
- Logs its invocation via :func:`src.observability.logger.log_tool_call`.
- Writes the generated artifact to disk under ``outputs/``.
- Returns a dict containing at minimum ``filepath`` and ``content`` keys.

Timestamps are embedded in every filename to avoid collisions.

Usage (called by agents via the ADK FunctionTool wrapper)::

    result = write_leadership_brief(
        program_name="Advanced Fighter Program (AFP)",
        intent="Monthly program review",
        what_happened="CPI declined to 0.87 ...",
        why_it_happened="Supplier quality escape ...",
        so_what="Program is projecting a $72M overrun ...",
        now_what="Release management reserve ...",
        risk_level="high",
    )
    print(result["filepath"])
"""

from __future__ import annotations

import json
import time
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict

from src.observability.logger import log_tool_call

# ---------------------------------------------------------------------------
# Resolve the outputs directory relative to the project root.
# Project root is three levels above this file: src/tools/artifact_tools.py
# ---------------------------------------------------------------------------
_PROJECT_ROOT = Path(__file__).resolve().parents[2]
_OUTPUTS_DIR = _PROJECT_ROOT / "outputs"
_BRIEFS_DIR = _OUTPUTS_DIR / "briefs"
_ARTIFACTS_DIR = _OUTPUTS_DIR / "artifacts"

_TOOL_MODULE = "artifact_tools"


def _ensure_dir(path: Path) -> None:
    """Create *path* and any parents if they do not already exist."""
    path.mkdir(parents=True, exist_ok=True)


def _timestamp_slug() -> str:
    """Return a filesystem-safe timestamp string (UTC) for use in filenames."""
    return datetime.now(timezone.utc).strftime("%Y%m%dT%H%M%SZ")


def _safe_filename(base: str) -> str:
    """Sanitise *base* so it is safe for use as a filename component."""
    return "".join(c if (c.isalnum() or c in "-_") else "_" for c in base)


# ---------------------------------------------------------------------------
# 1. Leadership Brief
# ---------------------------------------------------------------------------

def write_leadership_brief(
    program_name: str,
    intent: str,
    what_happened: str,
    why_it_happened: str,
    so_what: str,
    now_what: str,
    risk_level: str = "medium",
) -> dict:
    """Generate a leadership brief in Markdown using What / Why / So What / Now What structure.

    The brief is saved to ``outputs/briefs/<timestamp>_leadership_brief.md``
    and the content is returned alongside the filepath.

    Parameters
    ----------
    program_name:
        Display name of the program (e.g. ``"Advanced Fighter Program (AFP)"``).
    intent:
        The analytical question or intent that triggered this brief.
    what_happened:
        Concise summary of the situation or event.
    why_it_happened:
        Root-cause or contributing-factor explanation.
    so_what:
        Impact assessment -- why leadership should care.
    now_what:
        Recommended actions, decisions needed, or next steps.
    risk_level:
        Overall risk characterisation for the brief header.
        One of ``"low"``, ``"medium"``, ``"high"``, or ``"critical"``.
        Defaults to ``"medium"``.

    Returns
    -------
    dict
        ``{"filepath": "<absolute path>", "content": "<markdown text>"}``
    """
    start = time.perf_counter()
    params: Dict[str, Any] = {
        "program_name": program_name,
        "intent": intent,
        "risk_level": risk_level,
    }

    ts = _timestamp_slug()
    risk_label = risk_level.upper()
    generated_at = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")

    content = (
        f"# Leadership Brief -- {program_name}\n\n"
        f"**Generated:** {generated_at}  \n"
        f"**Risk Level:** {risk_label}  \n"
        f"**Intent:** {intent}\n\n"
        f"---\n\n"
        f"## What Happened\n\n{what_happened}\n\n"
        f"## Why It Happened\n\n{why_it_happened}\n\n"
        f"## So What\n\n{so_what}\n\n"
        f"## Now What\n\n{now_what}\n\n"
        f"---\n\n"
        f"*This brief was auto-generated by the Program Execution Workbench.*\n"
    )

    _ensure_dir(_BRIEFS_DIR)
    filepath = _BRIEFS_DIR / f"{ts}_leadership_brief.md"
    filepath.write_text(content, encoding="utf-8")

    result = {"filepath": str(filepath), "content": content}

    latency = (time.perf_counter() - start) * 1000
    log_tool_call(_TOOL_MODULE, "write_leadership_brief", params, result, latency)
    return result


# ---------------------------------------------------------------------------
# 2. CAM Variance Narrative
# ---------------------------------------------------------------------------

def write_cam_narrative(
    wbs_id: str,
    wbs_name: str,
    variance_explanation: str,
    corrective_actions: str,
    eac_impact: str,
) -> dict:
    """Generate a Control Account Manager (CAM) variance narrative.

    The narrative is saved to ``outputs/artifacts/<timestamp>_cam_narrative_<wbs_id>.md``
    and returned alongside the filepath.

    Parameters
    ----------
    wbs_id:
        Work Breakdown Structure element ID (e.g. ``"1.3.2"``).
    wbs_name:
        Human-readable title of the work package.
    variance_explanation:
        Explanation of the cost and/or schedule variance.
    corrective_actions:
        Planned or in-progress corrective actions.
    eac_impact:
        Description of how the variance affects the Estimate at Completion.

    Returns
    -------
    dict
        ``{"filepath": "<absolute path>", "content": "<markdown text>"}``
    """
    start = time.perf_counter()
    params: Dict[str, Any] = {"wbs_id": wbs_id, "wbs_name": wbs_name}

    ts = _timestamp_slug()
    generated_at = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")
    safe_wbs = _safe_filename(wbs_id)

    content = (
        f"# CAM Variance Narrative -- WBS {wbs_id}: {wbs_name}\n\n"
        f"**Generated:** {generated_at}  \n"
        f"**WBS Element:** {wbs_id}  \n"
        f"**Work Package:** {wbs_name}\n\n"
        f"---\n\n"
        f"## Variance Explanation\n\n{variance_explanation}\n\n"
        f"## Corrective Actions\n\n{corrective_actions}\n\n"
        f"## EAC Impact\n\n{eac_impact}\n\n"
        f"---\n\n"
        f"*This narrative was auto-generated by the Program Execution Workbench.*\n"
    )

    _ensure_dir(_ARTIFACTS_DIR)
    filepath = _ARTIFACTS_DIR / f"{ts}_cam_narrative_{safe_wbs}.md"
    filepath.write_text(content, encoding="utf-8")

    result = {"filepath": str(filepath), "content": content}

    latency = (time.perf_counter() - start) * 1000
    log_tool_call(_TOOL_MODULE, "write_cam_narrative", params, result, latency)
    return result


# ---------------------------------------------------------------------------
# 3. Risk Register Update
# ---------------------------------------------------------------------------

def write_risk_register_update(
    risk_id: str,
    title: str,
    probability: float,
    impact: str,
    mitigation: str,
    status: str,
    justification: str,
) -> dict:
    """Generate a risk register update entry.

    The update is saved to ``outputs/artifacts/<timestamp>_risk_update_<risk_id>.md``
    and the content is returned alongside the filepath.

    Parameters
    ----------
    risk_id:
        Unique risk identifier (e.g. ``"R-001"``).
    title:
        Short risk title.
    probability:
        Updated probability of occurrence (0.0 -- 1.0).
    impact:
        Updated impact level (``"low"``, ``"medium"``, ``"high"``, ``"critical"``).
    mitigation:
        Updated or new mitigation actions.
    status:
        Updated risk status (``"active"``, ``"watch"``, ``"mitigated"``, ``"closed"``, ``"accepted"``).
    justification:
        Rationale for the update -- why the probability, impact, or status changed.

    Returns
    -------
    dict
        ``{"filepath": "<absolute path>", "content": "<markdown text>"}``
    """
    start = time.perf_counter()
    params: Dict[str, Any] = {
        "risk_id": risk_id,
        "title": title,
        "probability": probability,
        "impact": impact,
        "status": status,
    }

    ts = _timestamp_slug()
    generated_at = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")
    safe_risk = _safe_filename(risk_id)

    content = (
        f"# Risk Register Update -- {risk_id}: {title}\n\n"
        f"**Generated:** {generated_at}  \n"
        f"**Risk ID:** {risk_id}  \n"
        f"**Status:** {status}  \n"
        f"**Probability:** {probability:.2f}  \n"
        f"**Impact:** {impact}\n\n"
        f"---\n\n"
        f"## Justification for Update\n\n{justification}\n\n"
        f"## Mitigation Plan\n\n{mitigation}\n\n"
        f"---\n\n"
        f"*This update was auto-generated by the Program Execution Workbench.*\n"
    )

    _ensure_dir(_ARTIFACTS_DIR)
    filepath = _ARTIFACTS_DIR / f"{ts}_risk_update_{safe_risk}.md"
    filepath.write_text(content, encoding="utf-8")

    result = {"filepath": str(filepath), "content": content}

    latency = (time.perf_counter() - start) * 1000
    log_tool_call(_TOOL_MODULE, "write_risk_register_update", params, result, latency)
    return result


# ---------------------------------------------------------------------------
# 4. Action Items
# ---------------------------------------------------------------------------

def write_action_items(items: str) -> dict:
    """Write an action-items list to a Markdown file.

    Parameters
    ----------
    items:
        A JSON string encoding a list of action-item dicts. Each dict must
        contain the keys ``action``, ``owner``, ``due_date``, ``priority``,
        and ``status``.

        Example::

            '[{"action": "Issue CAR to supplier", "owner": "D. Moreno",
              "due_date": "2024-12-15", "priority": "high", "status": "open"}]'

    Returns
    -------
    dict
        ``{"filepath": "<absolute path>", "content": "<markdown text>"}``

    Raises
    ------
    ValueError
        If *items* is not valid JSON or does not decode to a list.
    """
    start = time.perf_counter()
    params: Dict[str, Any] = {"items": items}

    parsed: list[dict] = json.loads(items)
    if not isinstance(parsed, list):
        raise ValueError("items must be a JSON-encoded list of dicts")

    ts = _timestamp_slug()
    generated_at = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")

    lines: list[str] = [
        f"# Action Items\n\n",
        f"**Generated:** {generated_at}  \n",
        f"**Total Items:** {len(parsed)}\n\n",
        "---\n\n",
        "| # | Action | Owner | Due Date | Priority | Status |\n",
        "|---|--------|-------|----------|----------|--------|\n",
    ]

    for idx, item in enumerate(parsed, start=1):
        action = item.get("action", "N/A")
        owner = item.get("owner", "N/A")
        due_date = item.get("due_date", "N/A")
        priority = item.get("priority", "N/A")
        status = item.get("status", "N/A")
        lines.append(
            f"| {idx} | {action} | {owner} | {due_date} | {priority} | {status} |\n"
        )

    lines.append(
        "\n---\n\n"
        "*This action-item list was auto-generated by the Program Execution Workbench.*\n"
    )

    content = "".join(lines)

    _ensure_dir(_ARTIFACTS_DIR)
    filepath = _ARTIFACTS_DIR / f"{ts}_action_items.md"
    filepath.write_text(content, encoding="utf-8")

    result = {"filepath": str(filepath), "content": content}

    latency = (time.perf_counter() - start) * 1000
    log_tool_call(_TOOL_MODULE, "write_action_items", params, result, latency)
    return result


# ---------------------------------------------------------------------------
# 5. 8D Problem-Solving Report
# ---------------------------------------------------------------------------

def write_eight_d_report(
    problem_description: str,
    containment: str,
    root_cause: str,
    corrective_action: str,
    preventive_action: str,
    verification: str,
) -> dict:
    """Generate an 8D problem-solving report.

    The 8D methodology (Eight Disciplines) is a structured approach for
    identifying root causes and implementing corrective/preventive actions.
    This function produces a Markdown report covering the key disciplines.

    The report is saved to ``outputs/artifacts/<timestamp>_eight_d_report.md``.

    Parameters
    ----------
    problem_description:
        Clear statement of the problem, including scope, impact, and how it
        was detected (disciplines D1/D2).
    containment:
        Interim containment actions taken to protect the customer / program
        while root cause is being determined (D3).
    root_cause:
        Results of root-cause analysis, including data and methods used (D4).
    corrective_action:
        Permanent corrective actions selected and implemented (D5/D6).
    preventive_action:
        Systemic changes to prevent recurrence on this and similar products
        or processes (D7).
    verification:
        Evidence that corrective and preventive actions are effective (D5/D8).

    Returns
    -------
    dict
        ``{"filepath": "<absolute path>", "content": "<markdown text>"}``
    """
    start = time.perf_counter()
    params: Dict[str, Any] = {
        "problem_description": problem_description[:200],
    }

    ts = _timestamp_slug()
    generated_at = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")

    content = (
        f"# 8D Problem-Solving Report\n\n"
        f"**Generated:** {generated_at}\n\n"
        f"---\n\n"
        f"## D1/D2 -- Problem Description & Team\n\n{problem_description}\n\n"
        f"## D3 -- Interim Containment Actions\n\n{containment}\n\n"
        f"## D4 -- Root Cause Analysis\n\n{root_cause}\n\n"
        f"## D5/D6 -- Permanent Corrective Actions\n\n{corrective_action}\n\n"
        f"## D7 -- Preventive Actions\n\n{preventive_action}\n\n"
        f"## D8 -- Verification & Closure\n\n{verification}\n\n"
        f"---\n\n"
        f"*This 8D report was auto-generated by the Program Execution Workbench.*\n"
    )

    _ensure_dir(_ARTIFACTS_DIR)
    filepath = _ARTIFACTS_DIR / f"{ts}_eight_d_report.md"
    filepath.write_text(content, encoding="utf-8")

    result = {"filepath": str(filepath), "content": content}

    latency = (time.perf_counter() - start) * 1000
    log_tool_call(_TOOL_MODULE, "write_eight_d_report", params, result, latency)
    return result


# ---------------------------------------------------------------------------
# 6. Contract Change Summary
# ---------------------------------------------------------------------------

def write_contract_change_summary(
    mod_number: str,
    description: str,
    cost_impact: str,
    schedule_impact: str,
    new_obligations: str,
    recommendation: str,
) -> dict:
    """Generate a contract change / modification summary.

    The summary is saved to
    ``outputs/artifacts/<timestamp>_contract_change_<mod_number>.md``
    and the content is returned alongside the filepath.

    Parameters
    ----------
    mod_number:
        Modification number (e.g. ``"P00027"``).
    description:
        Description of the modification scope and rationale.
    cost_impact:
        Summary of cost impacts (dollars, CLINs affected, funding changes).
    schedule_impact:
        Summary of schedule impacts (weeks of extension, milestones affected).
    new_obligations:
        New deliverables, CDRLs, or contractual obligations introduced.
    recommendation:
        Analyst recommendation regarding the modification.

    Returns
    -------
    dict
        ``{"filepath": "<absolute path>", "content": "<markdown text>"}``
    """
    start = time.perf_counter()
    params: Dict[str, Any] = {"mod_number": mod_number}

    ts = _timestamp_slug()
    generated_at = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")
    safe_mod = _safe_filename(mod_number)

    content = (
        f"# Contract Change Summary -- Mod {mod_number}\n\n"
        f"**Generated:** {generated_at}  \n"
        f"**Modification:** {mod_number}\n\n"
        f"---\n\n"
        f"## Description\n\n{description}\n\n"
        f"## Cost Impact\n\n{cost_impact}\n\n"
        f"## Schedule Impact\n\n{schedule_impact}\n\n"
        f"## New Obligations\n\n{new_obligations}\n\n"
        f"## Recommendation\n\n{recommendation}\n\n"
        f"---\n\n"
        f"*This contract change summary was auto-generated by the Program Execution Workbench.*\n"
    )

    _ensure_dir(_ARTIFACTS_DIR)
    filepath = _ARTIFACTS_DIR / f"{ts}_contract_change_{safe_mod}.md"
    filepath.write_text(content, encoding="utf-8")

    result = {"filepath": str(filepath), "content": content}

    latency = (time.perf_counter() - start) * 1000
    log_tool_call(_TOOL_MODULE, "write_contract_change_summary", params, result, latency)
    return result
